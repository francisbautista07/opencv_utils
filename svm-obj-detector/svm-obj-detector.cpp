#include <stdio.h>
#include <stdlib.h>

#include <iostream>
#include <fstream>
#include <opencv2/opencv.hpp>
#include <vector>

#include "cvu_hog.h"

using namespace std;
using namespace cv;

int main(int argc, char **argv)
{
	if(argc != 10) {
		cout << "Syntax: svm-obj-detect [image] [model] [win_length] [win_width] [hog_length] [hog_width] [kernel_cell_size] [block_size] [gaussian_blur]" << endl;
		cout << "==> image: the image file to search for objects in" << endl;
		cout << "==> model: the model file generated by svm training" << endl;
		cout << "==> win_length: length of the search window" << endl;
		cout << "==> win_width: width of th search window" << endl;
		cout << "==> hog_length: length of the hog window" << endl;
		cout << "==> hog_width: width of the hog window" << endl;
		cout << "==> kernel_cell_size: hog cell size" << endl;
		cout << "==> block_size: hog block size" << endl;
		cout << "==> gaussian_blur: hog gaussian blur" << endl;
		exit(-1);
	}

	string image_file = argv[1];
	string model_file = argv[2];
	int win_length = atoi(argv[3]);
	int win_width = atoi(argv[4]);
	int hog_length = atoi(argv[5]);
	int hog_width = atoi(argv[6]);
	int kernel_cell_size = atoi(argv[7]);
	int block_size = atoi(argv[8]);
	int gaussian_blur = atoi(argv[9]);

	Mat search_image = imread(image_file);
	Mat output_image;
	search_image.copyTo(output_image);
	int length = search_image.rows;
	int width = search_image.cols;

	cout << "Image file: " << image_file << endl;
	cout << "Search image length: " << length << endl;
	cout << "Search image width: " << width << endl;
	cout << "Search window: " << win_width << " x " << win_length << endl;
	cout << "Hog size: " << hog_width << " x " << hog_length << endl;
/*
	if(length % win_length != 0 || width % win_width != 0) {
		cerr << "Invalid search window parameters" << endl;

		exit(-1);
	}
*/
	// Load SVM model
	CvSVM svm;
  svm.load(model_file.c_str());

	// Search through each sub window
	cout << "Detecting..." << endl;
	for(int col = 0; col < (width - win_width); col++) {
		for(int row = 0; row < (length - win_length); row++) {
			Rect r(col, row, win_width, win_length);
			Mat sub_mat = search_image(r);
			cvtColor(sub_mat, sub_mat, CV_BGR2GRAY);
			resize(sub_mat, sub_mat, Size(hog_length, hog_width));

			vector<HOG_BLOCK> hog_blocks = compute_hog_features(sub_mat, kernel_cell_size, block_size, gaussian_blur);
			int dimension = 0;
			for(int i = 0; i < hog_blocks.size(); i++) {
		  	for(int j = 0; j < hog_blocks.at(i).normalized_hogs.size(); j++) {
		  		for(int b = 0; b < BIN_COUNT; b++) {
		  			dimension++;
		  		}
		  	}
		  }

			vector<float> feature_set;
			Mat new_instance = Mat_<float>(1, dimension);
			for(int i = 0; i < hog_blocks.size(); i++) {
		  	for(int j = 0; j < hog_blocks.at(i).normalized_hogs.size(); j++) {
		  		for(int b = 0; b < BIN_COUNT; b++) {
		  			feature_set.push_back(hog_blocks.at(i).normalized_hogs.at(j).at(b));
		  		}
		  	}
		  }

		  for(int i = 0; i < feature_set.size(); i++) {
		  	new_instance.at<float>(0, i) = feature_set.at(i);
		  }

		  float response = svm.predict(new_instance);
		  cout << "Response: " << response << endl;
		  if(response == 1) {
		  	rectangle(output_image, Point(col, row), Point(col + win_width, row + win_length), Scalar(255, 0, 0));
		  }		
		}
	}

	imshow("OUTPUT", output_image);
	waitKey(0);

	return 0;
}